"""
Write generator merge(…) which accepts as arguments an arbitrary number of iterables, 
each of which generates sorted numbers, not necessarily one after another.
merge() must merge the outputs of the iterables, 
i.e. give a sorted queue of all the numbers from the input iterables.
merge() must correctly stop if all of the input iterables have stopped. 

E.g., the input iterables are three generators giving the following numbers:
Iterable 1: 1, 5, 9
Iterable 2: 2, 5
Iterable 3: 1, 6, 10, 11

The sequence generated by merge(…) in this case must be: 1, 1, 2, 5, 5, 6, 9, 10, 11
 dawda d Da

NOTE: There exists a standard python solution based on heapq.merge,
but we would like that you write your solution 
from scratch without using heapq module.


The following aspects will be taken into account for evaluation:
# Create unit tests to cover the functionality
# Working solution
# Structure
# Maintainability
# Re-usability
# Code quality
# Reliability
# Logging and evidence management

Once Finished
# Share the link to a public online repository containing the solution implemented.
# NOTE: If not finished, but running out of time, please share your implementation.
# We will be glad to evaluate it anyway.
"""


def merge(*iterables, key=None, reverse=False):
    """Alternative for heapq.merge
    Takes as an input iterables and returns them joined as sorted generator.

    Args:
        key (funcion, optional): parameter to specify a function (or other callable)
                                 to be called on each list element prior to making comparisons.
                                 Defaults to None.
        reverse (bool, optional): Reverse or not. Defaults to False.

    Returns:
        generator: Sorted iterables
    """
    rtn_list = []
    for item in iterables:
        for i in item:
            rtn_list.append(i)
    # creates a generator object
    data = sorted(rtn_list, key=key, reverse=reverse)
    data_gen = (y for y in data)
    return data_gen
